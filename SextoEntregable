// Ejercicio 13 Practica 8
int minimoCosto(vector<vector<int>> m){
    int i = 0; //O(1)
    int j = 0; //O(1)
    int sum = m[i][j]; //O(1)
    while(i < m.size() - 1 && j < m.size() - 1){ //O(n)
        if(m[i][j+1] <= m[i+1][j]){ //O(1)
            j++; //O(1)
        } else {
            i++; //O(1)
        }
        sum = sum + m[i][j]; //O(1)
    }
    if(i < m.size() - 1){ //O(1)
        i++; //O(1)
        while(i < m.size()){ //O(n)
            sum = sum + m[i][j]; //O(1)
            i++; //O(1)
        }
    } else {
        if(j < m.size() - 1){ //O(1)
            j++;  //O(1) (Primero tengo que incrementar j porque si pongo primero sum = sum + m[i][j] me va a volver a sumar el ultimo casillero que ya sume)
            while(j < m.size()){ //O(n)
            sum = sum + m[i][j]; //O(1)
            j++; //O(1)
            }
        } 
    }
    return sum; //O(1)
}

//Complejidad: 2*O(n) = O(n)
